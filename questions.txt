1. Что такое сервлет?
Это интерфейс. Его реализации работают на сервере с клиентом по схеме запрос-ответ. Частный случай - HttpServlet, работает по протоколу http

2. Какова структура веб-проекта?
	Есть контейнер сервлетов, в который помещается веб проект:
* в корне будут лежать html, jsp файлы
* в папке WEB_INF:
    * web.xml - дескриптор развертывания, определяет маппинг url-servlet, некоторые другие параметры  приложения (например время жизни сессии)
    * в папке classes - скомпилированные классы: Сервлеты, Фильтры и т.д. т.е. код, написанный нами
    * в папке Lib - сторонние зависимости: те библиотеки, кторые были подключены в pom.xml

3. Что такое контейнер сервлетов?
	Программа, которая управляет жизненным циклом сервлетов. Работая на сервере, обеспечивает заимодействие по сети
клиента и сервлетов - формирует ответ на запрос клинта.
Кроме маршрутизации запросов, контейнер сервлетов выполняет и другие функции:
*Динамически генерирует HTML-страницы с JSP-файлов.
*Зашифровывает/расшифровывает HTTPS-сообщения.
*Предоставляет разграниченный доступ для администрирования сервлетов.

4. Каковы задачи, функциональность контейнера сервлетов?

5. Что вы знаете о сервлет фильтрах?
	Это ссвоего рода Request, Response препроцессор. т.е., преже чем попасть на соответсвующий сервлет, Req попадет
на соответствующие фильтры. А так же Resp перед отпарвкой клиенту так же попадаетв фильтр. Фильты могут их модифицировать или просто логировать события

6. Зачем нужны слушатели в сервлетах?
	Существует несколько интерфейсов, которые позволяют следить за событиями, связанными с сеансом, контекстом и запросом сервлета,
генерируемыми во время жизненного цикла Web-приложения.	Слушатели  - могут следить за тем, когда в соответсвующем компоненте произошли определенные
события - были инициализированы, или отслеживать время, когда они должны быть уничтожены, и когда атрибуты были добавлены или удалены.

* ServletRequestListener
* ServletRequestEvent
* ServletRequestAttributeListener
* ServletRequestAttributeEvent
Слушатели - это классы, с помощью которых можно отслеживать изменения ключевых параметров в веб-приложении.
Слушатели делятся на два уровня: уровень контекста (приложения, servlet-context-level) и уровень сессии (servlet-session-level)
Внутри уровней слушатели делятся на две группы: отслеживающие изменение атрибутов и отслеживающие изменения в жизненном цикле.
Для оповещений используются классы Event из пакета javax.servlet. В этих классах есть методы для получения самого объекта - ServletContextEvent: getServletContext()
ServletContextAttributeEvent - HttpSessionAttributeEvent: getHttpSession()

7. Когда вы будете использовать фильтры, а когда слушатели?
	Фильтры используются до того как запрос достигнет сервлета или после того, как ответ будет сгенерирован, но перед его отправкой пользователю.
 В то время как слушатели используются для обработки жизненных циклов внутренних объектов: сеансов и атрибутов в сервлете.
 Фильтры обрабатывают все проходящие мимо них запросы.
 Они не интересуются реализацией и взаимодействием сервлетов.
 Фильтры можно использовать:
 * для аутентификации пользователей (доступ к сервлетам)
 * шифрование/расшифровка передаваемых/получаемых данных.
 * логирование
	Слушатели более специфичны: реагируют только на указанные события, а не на все.
Они могут:
* слушатель контекста: создавать/завершать подключение к базе данных при старте/выключении приложения
*слушатель сессии: создавать/изменять объекты, специфичные для залогиненого пользователя. 

8. Как обработать исключения, выброшенные другим сервлетом в приложении?
	Основная идея заключается в том, чтобы отправить клиенту хотябы какой-то понятный ответ, если произошла ошибка в сервлете.
Даже если отправить просто статус ошибки - браузер сообщит об этом клиенту. Но так же можно сконфигурировать контейнер сервлетов так,
что при определенных ошибках, ответ ему отдавал бы определенный сервлет.

9. Что такое дескриптор развертывания?

10. Как реализовать запуск сервлета с запуском приложения?
Контейнер сервлетов обычно загружает сервлет при первом запросе клиента, но иногда необходимо загрузить сервлет прямо на старте приложения
(например если сервлет объемный и будет долго грузиться). Для этого необходимо использовать элемент load-on-startup в дескрипторе
(или аннотацию loadOnStartup), который укажет необходимость загрузки сервлета при запуске.
	<servlet>
    		<servlet-name>foo</servlet-name>
    		<servlet-class>com.foo.servlets.Foo</servlet-class>
    		<load-on-startup>5</load-on-startup>
	</servlet>
Значение должно быть int. Если значение отрицательное, то сервлет будет загружен при запросе клиента, а если 0 и далее, то загрузится
на старте приложения. Чем меньше число, тем раньше в очереди на загрузку будет сервлет.

11. Что представляет собой объект ServletConfig?
	Добавляет возможность сконфигурировать определенный сервлет через web.xml (или @WebInitParam). Для передачи конфигурационной
информации сервлету используется ServletConfig, за создание экземпляра которого ответственен контейнер сервлетов.
Для получения объекта ServletConfig данного сервлета используется метод getServletConfig().

12. Что представляет собой объект ServletContext?
	Предоставляет доступ к параметрам веб приложения сервлету. Объект ServletContext является уникальным и доступен всем
сервлетам веб приложения. Мы можем использовать объект ServletContext, когда нам необходимо предоставить доступ одному или нескольким
сервлетам к инициализированным параметрам веб приложения. Для этого используется элемент <context-param> в web.xml.
Объект ServletContext можно получить с помощью метода getServletContext() у интерфейса ServletConfig, Servlet.
Контейнеры сервлетов так же могут предоставлять context объекты, уникальные для группы сервлетов. Каждая из групп будет связана со своим
набором URL путей хоста. ServletContext был расширен в спецификации Servlet 3 и предоставляет программное добавление слушателей
и фильтров в приложение. Так же у этого интерфейса имеются множество полезных методов вроде getMimeType(), getResourceAsStream() и т.д..

13. В чем отличия ServletContext и ServletConfig?
* ServletConfig является уникальным объектом для каждого сервлета, в то время как ServletContext уникальный для всего приложения.
* ServletConfig используется для предоставления параметров инициализации сервлету, а ServletContext для предоставления параметров
инициализации приложения для всех сервлетов.
* У нас нет возможности устанавливать атрибуты в объекте ServletConfig, в то время как можно установить атрибуты в объекте ServletContext,
которые будут доступны другим сервлетам.

14. Что такое Request Dispatcher?
	Используется для передачи запроса другому ресурсу (это может быть HTML, JSP или другой сервлет в том же приложении).
Мы можем использовать это для добавления контента другого ресурса к ответу. Этот интерфейс используется для внутренней коммуникации
между сервлетами в одном контексте. В интерфейсе реализовано два метода:
* void forward(ServletRequest req, ServletResponse resp) – передает запрос из сервлета к другому ресурсу (сервлету, JSP или HTML файлу) на сервере.
* void include(ServletRequest req, ServletResponse resp) – включает контент ресурса (сервлет, JSP или HTML страница) в ответ.
Доступ к интерфейсу можно получить с помощью метода ServletContext getRequestDispatcher(String s). Путь должен начинаться с / ,
который будет интерпретироваться относительным текущего корневого пути контекста.

15. Как можно создать блокировку (deadlock) в сервлете?
Дедлок можно получить реализовав зацикленный вызов метода, например вызвав метод doPost() в методе doGet() и вызвать doGet() в методе doPost().

16. Как получить адрес сервлета на сервере?
Для получения актуального пути сервлета на сервере можно использовать эту конструкцию: getServletContext().getRealPath(request.getServletPath())

17. Как получить информацию о сервере из сервлета?
из сервлета: this.getServletContext().getServerInfo()

18. Как получить ip адрес клиента на сервере?
из сервлета: req.getRemoteAddr()

19. Что вы знаете о классах обертках (wrapper) для сервлетов?
В Servlet HTTP API предоставляются два класса обертки – HttpServletRequestWrapper и HttpServletResponseWrapper.
Они помогают разработчикам реализовывать собственные реализации типов request и response сервлета.

20. Каков жизненный цикл сервлета и когда какие методы вызываются?
Загрузка класса сервлета – когда контейнер получает запрос для сервлета, то происходит загрузка класса сервлета в память
и вызов конструктора без параметров.
Инициализация класса сервлета – после того как класс загружен контейнер инициализирует объект ServletConfig для этого сервлета и внедряет
его через init() метод. Это и есть место где сервлет класс преобразуется из обычного класса в сервлет.
Обработка запросов – после инициализации сервлет готов к обработке запросов. Для каждого запроса клиента сервлет контейнер порождает новую нить (поток) и
вызывает метод service() путем передачи ссылки на объект ответа и запроса.
Удаление из Service – когда контейнер останавливается или останавливается приложение, то контейнер сервлетов уничтожает классы сервлетов путем вызова destroy() метода.
	Можно описать как последовательность вызова методов: init(), service(), destroy().
public void init(ServletConfig config) – используется контейнером для инициализации сервлета. Вызывается один раз за время жизни сервлета.
public void service(ServletRequest request, ServletResponse response) – вызывается для каждого запроса. Метод не может быть вызван раньше выполнения init() метода.
public void destroy() – вызывается для уничтожения сервлета (один раз за время жизни сервлета).

21. Какие методы необходимо определить при создании сервлетов?
* задать url-mapping в web.xml или через аннотацию
* класс сервлета должен расширять HttpServlet
* в классе сервлета необходимо реализовать метод service или doGet / doPost

22. В каком случае вы будете переопределять метод service()?
 - если серлет будет одинаковым образом обрабатывать методы doGet, doPost

23. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?
    Инициализировать данные лучше переопределив метод init(), в котором получить доступ к параметрам инициализации сервлета через использование объекта ServletConfig.

24. В чем отличия GenericServlet и HttpServlet?
    Абстрактный класс GenericServlet – независимая от используемого протокола реализация интерфейса Servlet.
HttpServlet, как понятно из название, реализация интерфейса сервлета для протокола HTTP. Следует отметить, что HttpServlet extends GenericServlet.

25. Как вызвать из сервлета другой сервлет этого же и другого приложения?
    Если необходимо вызывать сервлет из того же приложения, мы можем вызвать другой сервлет с помощью RequestDispatcher forward() и include() методов
для доступа к дополнительным атрибутам в запросе для использования в другом сервлете. Метод forward() используется для передачи обработки запроса в другой сервлет.
Метод include() используется, если мы хотим вложить результат работы другого сервлета в возвращаемый ответ.
Если необходимо вызывать сервлет из другого приложения, то использовать RequestDispatcher уже не получится (определен для приложения).
Поэтому можно использовать ServletResponse sendRedirect() метод и предоставить полный URL из другого сервлета.
Для передачи данных можно использовать cookies как часть ответа сервлета, а потом использовать их в нашем сервлете.

26. Что вы знаете и в чем отличия методов forward() и sendRedirect()?
* RequestDispatcher forward() используется для проброски того же самого запроса к другому ресурсу, в то время как
ServletResponse sendRedirect() это двухшаговый метод. Во втором методе веб приложение возвращает ответ клиенту с status code 302 (redirect) с ссылкой для отправки запроса.
Клиент посылает полностью новый запрос.
forward() обрабатывается внутри контейнера, а sendRedirect() обрабатывается браузером.
Необходимо использовать forward() для организации доступа внутри одного и того же приложения, т.к. он быстрее sendRedirect(), которому требуется дополнительная сетевая работа.
В методе forward() браузер не знает о фактически обрабатываемом ресурсе и URL в строке остается прежним. В sendRedirect() методе URL адрес изменяется на пробрасываемый ресурс.
В методе forward() нельзя использовать для внедрения сервлета в другой контекст. Для этого можно использовать только sendRedirect().

27. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?
Методы класса HTTPServlet init() и destroy() вызываются один раз за жизненный цикл сервлета – поэтому по поводу них беспокоиться не стоит.
Методы service(), doGet(), doPost(), doFilter() вызываются на каждый запрос клиента и т.к. сервлеты используют многопоточность, то здесь нужно задумываться о потокобезопасной работе.
В случае наличия локальных переменных в этих методах нет необходимости думать о многопоточной безопасности, т.к. они будут созданы отдельно для каждой нити.
Но если используются глобальные ресурсы, то необходимо использовать синхронизацию как и в любом многопоточном приложении Java.

28. В чем отличие между веб сервером и сервером приложений?
    Основная задача web сервера - обрабатывать Http запросы и отдавать Http ответы (ГОТОВАЯ странца, файл... т.е. статичный контент - статичный на стороне сервера).
Нет возможности строить сложную логику. Т.е.  web сервер отдает готовый контент, без возможности изменить его.
    App сервер так же обрабатыевает http запросы (содержит в себе web сервер), но при этом эти ответы он фоимирует сам. т.о. формируется динамический контент - динамика на строне сервера.
Есть возможность строить сложную логику на основании содержания запроса, сессионных данных, кук. Содержит доп. возможности в сравнении с веб сервером.

29. Какой метод HTTP не является неизменяемым?
    HTTP метод называется неизменяемым, если он всегда возвращает одинаковый результат. HTTP методы GET, PUT, DELETE, HEAD, OPTIONS являются неизменяемыми.
Необходимо реализовывать приложение так, чтобы эти методы возвращали одинаковый результат.
    К изменяемым методам относится HTTP метод POST. Post метод используется для реализации чего-либо, что изменяется при каждом запросе.
К примеру, для доступа к HTML странице или изображению необходимо использовать метод GET, т.к. он возвращает одинаковый результат.
Но если нам необходимо сохранить информацию о заказе в базе данных, то нужно использовать POST метод.
Неизменяемые методы так же известны как безопасные методы и нет необходимости заботиться о повторяющихся запросах от клиента для этих методов.

30. Почему HttpServlet класс объявлен как абстрактный?
    Чтобы можно было реализовать только те методы, котрые необходимо реализовать. Например необходимо реализвать только doGet, значит doPost можно не трогать
- на работе приложения это никак не скажется (если прийдет запрос на нереализованный метод, сервлет вернет 405 ошибку - HTTP 405 Method Not Implemented error)

31. В чем разница между методами GET и POST?
* GET метод является неизменяемым, тогда как POST – изменяемый.
* С помощью метода GET можно посылать ограниченное кол-во данных, которые будут пересланы в заголовке URL.
    В случае POST метода мы можем пересылать большие объемы данных, т.к. они будут находится в теле метода.
* Данные GET метода передаются в открытом виде, что может использоваться в зловредных целях. POST данные передаются в теле запроса и скрыты от пользователя.
* GET метод является HTTP методом по умолчанию, а POST метод необходимо указывать явно, чтобы отправить запрос.
* GET метод используется гиперссылками на странице.

32. Что такое MIME-тип?
    — типы данных, которые могут быть переданы посредством сети Интернет с применением стандарта MIME.
Сервер посылает MIME тип клиенту для того, чтобы он понял какой тип данных пересылается. Это помогает верно отобразить полученные данные на клиенте.
Наиболее часто используемые MIME типы: text/html, text/xml, application/xml и многие др.
В ServletContext существует метод getMimeType() для получения корректного MIME типа файла и дальнейшего использования этой информации для указания типа контента в ответе.

33. Назовите преимущества Servlet над CGI?
    Common Gateway Interface или общий интерфейс шлюза
    Исторически cgi был одним из первых подходов для создания динамических сайтов. При запросе, на стороне сервера запускается выполенение скрипта.
Т.о. на каждый запуск и соответсвенно на каждый запрос ОС выделяла процесс и если одновременно пришло n запросов на один одресс, в памяти компьютера одновременно исполняются
n одинаковых скриптов. Cgi тенология имеет определенные проблемы с безопасностью, т.к. скипты могут быть написаны на низкоуровневых языках (например C), которые имеют доступ к
памяти, могут стирать данные... Т.о. сам сервер только лишь запускал скрипт.
* Сервлеты предоставляют лучшую производительность в условиях обработки запросов, лучшее использование памяти за счет использования
преимуществ многопоточности (на каждый запрос создается новая нить, что быстрее выделения памяти под новый объект для каждого запроса, как это происходит в CGI).
* Сервлеты, платформа и система являются независимыми. Таким образом веб приложение написанное с использованием сервлетов может быть запущена
в любом контейнере сервлетов, реализующим стандарт и в любой операционной системе.
* Использование сервлетов повышает надежность программы, т.к. контейнер сервлетов самостоятельно заботится о жизненном цикле сервлетов
(а значит и за утечками памяти), безопасности и сборщике мусора.
* Сервлеты относительно легки в изучении и поддержке, таким образом разработчику необходимо заботиться только о бизнес логике приложения, а не внутренней реализации веб технологий.

34. Каковы наиболее распространенные задачи выполняются в Servlet контейнере?
* Работа с Socket connection, создание сессий, разбор запроса, ответа
* Работа с многопотчностью - каждый запрос обрабатывается в отдельном потоке
* -> Маршрутизация запроса соответствующему фильру -> сервлету
* https encoding/decoding
* Динмическая генерация html кода из шаблонов JSP, Thymeleaf, FreeMarket, Mustache

35. В чем разница между PrintWriter и ServletOutputStream?
PrintWriter – это класс для работы с символьным потоком, а ServletOutputStream – класс для работы байтовым потоком.
PrintWriter используется для записи информации на основе символов, вроде массива символов или строки в ответ, в то время как
ServletOutputStream используется для записи в ответ массива байтов. Для получения экземпляра ServletOutputStream используется метод ServletResponse getOutputStream(),
а для PrintWriter – метод ServletResponse getWriter().

36. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?
Мы не можем создать два объекта этих классов в одном сервлете. При попытке внедрить оба метода getWriter() и getOutputStream() в ответе, мы получим исключение
java.lang.IllegalStateException с сообщением, что уже другой метод был вызван для этого ответа.

37. Расскажите о интерфейсе SingleThreadModel.
Интерфейс был создан, чтобы гарантировать потокобезопасность и невозможности создания двух нитей в сервис методе сервлета.
Однако интерфейс SingleThreadModel не решает всех проблем потокобезопасности. Например, атрибуты сессии или статические переменные могут быть доступны различным
запросам в различных потоках в одно и тоже время (даже при использовании этого интерфейса). В общем это убило весь профит
от многопоточности и интерфейс объявлен deprecated начиная с Servlet 2.4.

38. Какие существуют атрибуты у сервлетов и какая сфера их применения?
Атрибуты сервлетов ипользуются для внутренней коммуникации сервлетов. Мы можем использовать атрибуты set, get, remove в веб приложении.
Существует три области видимости атрибутов – request scope, session scope, application scope.
Интерфейсы ServletRequest, HttpSession и ServletContext предоставляют методы для get(), set(), remove() атрибутов из request scope, session scope, application scope соответственно.
HttpServletRequest.getSession()
this.getServletContext().setAttribute();

39. Почему необходимо переопределить только init() метод без аргументов?
Если нам необходимо инициализировать какие-то ресурсы до того как сервлет начнет обрабатывать запросы, то необходимо переопределить метод init().
Если переопределить метод init(ServletConfig config), то первым должен быть вызван метод super(config), который обеспечит вызов метода init(ServletConfig config) суперкласса.
    Именно поэтому GenericServlet предоставляет другой метод init() без параметров, который будет вызываться в конце метода init(ServletConfig config).
Разработчик должен использовать переопределенный метод init() без параметров для инициализации переменных для избежания каких-либо проблем,
например не указав вызов super() в переопределенном методе init(ServletConfig config).

40. Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode() и decode()?
Кодирование URL и просто двоичных данных в последовательность букв, цифр и некоторых специальных знаков латинского алфавита в интернете было связано с
ограничением физических устройств на передачу только алфавитно-цифровых символов (протокол http предназначен для передачи текстовой информации, при э
том мы можем передавать звук, картики и т.д. (mime type)). В URL такое кодирование обычно применяется для передачи символов в
формате Unicode (как правило UTF-8) в последовательность из двух байт, записанных в шестнадцатиричном представлении. Каждый байт предваряется знаком %.
При таком кодировании строчка "корова" будет иметь вид: %D0%BA%D0%BE%D1%80%D0%BE%D0%B2%D0%B0. То есть русской букве к будет соответствовать последовательность %D0%BA и.т.д.
Такое кодирование является общепринятым для путей к файлам или папкам, входящим в URL.
    Для кодирования строки используется метод  java.net.URLEncoder.encode(String str, String unicode).
Обратная операция декодирования возможна благодаря методу java.net.URLDecoder.decode(String str, String unicode).

41. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?
HttpServletResponse предоставляет методы преобразования URL в HTML гиперссылки с преобразованием спец символов и пробелов, а так же добавления session id к URL.
Такое поведение аналогично URLEncoder encode(), но с добавлением дополнительного параметра jsessionid в конец URL.
Метод HttpServletResponse encodeRedirectUrl() применяется для преобразования redirect URL в ответе.
Таким образом при предоставлении поддержки URL rewriting для HTML гиперссылок необходимо использовать encodeURL(), а для редирект URL’ов использовать encodeRedirectUrl().

42. Какие различные методы управления сессией в сервлетах вы знаете?
    Вообще протокол http являтся stateless - не обязывает хранить какие-то данные. Связь между клиентом и сервером заканчивается как только завершается обработка текущего запроса.
Каждый новый запрос к серверу подразумевается как абсолютно уникальный и независимый, даже если он был отправлен повторно от одного и того же источника.
    Но очень часто нужно идентифицировать клиента, и для того, чтобы каждый такой запрос не сопровождать аутентификацией, придуман механизм сессий - когда за время жизни сессии,
сервер может определять все запросы от одного клиента. Существует несколько техник управления сессиями клиента, их количество и способ реализации во многом зависит от
веб-платформы или технологии, что работает на сервере.
* Аутентификация пользователя - пользователь может предоставить учетные данные для аутентификации со страницы входа в систему, а затем мы можем передавать данные
аутентификации между сервером и клиентом для поддержания сеанса.
* хранить сессионные данные в куках (но пользователь может запреитить использовать куки или браузер их может не поддерживать)
* HTML hidden field (При первичном посещении ресурса, сервер в ответе отправляет html документ со скрытыми полями, в которых сохранены сессионные данные, и далее все запросы
сопровождаются этими данными, а сервер, обрабатывая эти запросы опять помещает сессионные данные в ответе)
* URL Rewriting - мы можем управлять сеансом с помощью HttpSession, но если мы отключим файлы cookie в браузере, это не будет работать, потому что сервер не получит файл
cookie JSESSIONID от клиента. Servlet API обеспечивает поддержку перезаписи URL, которую мы можем использовать в этом случае для управления сеансом.
С точки зрения кодирования он очень прост в использовании и требует одного шага - кодирования URL.
Еще одно преимущество кодирования URL сервлета - это резервный подход, и он срабатывает только в том случае, если файлы cookie браузера отключены.
Мы можем кодировать URL-адрес с помощью метода HttpServletResponse encodeURL (), и если нам нужно перенаправить запрос на другой ресурс,
и мы хотим предоставить информацию о сеансе, мы можем использовать метод encodeRedirectURL ().
*  Session Management API - технология J2EE Servlet поставляется с Session Management API, который мы можем использовать.

43. Что означает URL Rewriting?
44. Как применяются Cookies в сервлетах?
Механизм кук это часть взаимодействия клиента и сервера по http протоколу. Клиент отпраляет запрос на сервер, в ответе сервера есть заголовок "set cookie coolie-name=cookie-value"
т.е. кука с содержанием ключ-значение и некоторыми параметрами.
Если клиент реализует механизм кук, то он запоминает куки и в ответе вставляет заголовок cookie со всеми куками от этого сервера.
Servlet API предоставляет поддержку cookies через класс javax.servlet.http.Cookie. Для получения массива cookies из запроса необходимо воспользоваться методом
HttpServletRequest getCookies().
Аналогично HttpServletResponse addCookie(Cookie c) – может добавить cookie в response header.

45. Как уведомить объект в сессии, что сессия недействительна или закончилась?

46. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?
Самый очевидный способ - использовать фильтры.

47. Как мы можем обеспечить transport layer security для нашего веб приложения?
Это касается реализации протокола https (HyperText Transfer Protocol Secure) - расширения протокола HTTP. Обычный http работает поверх tcp-ip, https работает поверх tls/ssl,
который в свою очередь шифрует данные tcp-ip передаваемые в открытом виде. TLS обеспечивает шифрование данных, защиту от изменений передаваемых данных и аутентификацию клиента
Веб сервер, работающий по https запускается на 443 порту (http - 80й порт). Шифрование происходит перед тем, как информация попадает на транспортный уровень.
В HTTPS шифруется абсолютно вся информация, кроме хоста и порта, куда отправлен запрос. Процесс шифрования мы делегируем контейнеру сервлетов.
Сам сертификат можно сгенерировать самостоятельно (используя специальную утилиту, например keytool из jdk), но на такой сертификат будут "ругаться" браузеры, т.к. он самоподписанный.
Выдачей TLS-сертификатов занимаются удостоверяющие центры. Функция удостоверяющих центров — осуществить проверку пользователя и заверить подлинность ресурса.
Существуют тысячи УЦ, некоторые из которых имеют бесплатные предложения.
Имея сертификат, нужно настроить сервер для его использования.

48. Как организовать подключение к базе дынных и обеспечить логирование log4j в сервлете?
    Можно использовать пул соединений (например из apache commons dbcp2 BasicDatasource), чтобы не открывать новое соединение при каждом запросе. Инициализировать его можно например
из ServletContextListener при инициализации контекста и установив у контекста соответствующий аттрибут, т.о. этот пул будет доступен внутри контекста.
    То же качается и логгера. Его можно создать в ServletContextListener и установить аттрибутом контекста.

49. Какие важные особенности существуют в Servlet 3?
* Servlet Annotations. До Servlet 3 весь маппинг был в web.xml, что приводило к ошибкам и банально неудобно при большом количестве сервлетов.
Примеры аннотаций:  @WebServlet, @WebInitParam, @WebFilter, @WebListener.
* Web Fragments. Проблема с web.xml заключается в том, что он не модульный. Все сведения о конфигурации одного конкретного приложения включены в один файл web.xml.
Предполагая, что если одно отдельное приложение использует один или несколько фреймворков поверх него, нет никакого способа проинструктировать контейнер сервлета об
использовании других фреймворков, единственный вариант - отредактировать дескриптор развертывания web.xml. Спецификация Servlet 3.0 решает эту проблему, вводя веб-фрагменты.
Веб-фрагмент можно рассматривать как один из сегментов всего web.xml, и можно представить, что один или несколько веб-фрагментов составляют один файл web.xml.
Веб-фрагмент может включать все возможные элементы, применимые к web.xml. Рассмотрим пример файла веб-фрагмента,
С появлением веб фрагментов мы можем содержать множество модулей. Все модули прописываются в fragment.xml в META-INF директории.
Это позволяет разделять веб приложение на отдельные модули, включенные как JAR файлы в отдельной lib директории.
* Динамическое добавление веб компонентов. Используя ServletContext объект, мы можем программно добавлять фильтры и слушатели. Это помогает построить динамическую систему,
в которой необходимый объект будет вызван только по необходимости. Для этого применяются методы addServlet(), addFilter(), addListener().
* Асинхронное выполнение. Если при обработке запроса мы обращаемся к стороннему ресурсу, и время ответа может быть большим, получается что на время ожидания ответа, поток, обрабатывающий
запрос, будет заблокирован. Запрос можно перевести в асинхронный режим, вызвав метод ServletRequest.startAsync (), который возвращает объект AsyncContext.
Также можно указать продолжительность тайм-аута, вызвав метод ServletRequest.setAsyncTimeout ().
В этом случае ответ может быть зафиксирован двумя способами: один - вызвать метод complete (), который определен в объекте AsyncContext, а другой - когда истекло время ожидания,
первоначально установленное для объекта запроса.
    Также возможно добавить асинхронные прослушиватели к объекту запроса для получения уведомлений о том, завершена ли асинхронная операция или истекло время ожидания.

50. Каковы различные способы аутентификации сервлета?
* Basic — наиболее простая схема, при которой username и password пользователя передаются в заголовке Authorization в незашифрованном виде (base64-encoded).
Однако при использовании HTTPS протокола, является относительно безопасной.
* Digest — challenge-response-схема, при которой сервер посылает уникальное значение nonce, а браузер передает MD5 хэш пароля пользователя, вычисленный с использованием указанного nonce. Более безопасная альтернативв Basic схемы при незащищенных соединениях, но подвержена man-in-the-middle attacks (с заменой схемы на basic). Кроме того, использование этой схемы не позволяет применить современные хэш-функции для хранения паролей пользователей на сервере.
* Forms authentication. Работает это по следующему принципу: в веб-приложение включается HTML-форма, в которую пользователь должен ввести свои credentials и отправить их
на сервер через HTTP POST для аутентификации. В случае успеха веб-приложение создает session token, который обычно помещается в browser cookies.
При последующих веб-запросах session token автоматически передается на сервер и позволяет приложению получить информацию о текущем пользователе для авторизации запроса.
Перехват session token зачастую дает аналогичный уровень доступа, что и знание username/password. Поэтому все коммуникации между клиентом и сервером в случае forms
authentication должны производиться только по защищенному соединению HTTPS.

51. Написать сервлет, реализующий загрузку файла на сервер.
    Http протокол позволяет передавать файлы между клиентом и сервером. На стороне клиента В html документе есть форма загрузки файла. <input type="file" name="file">
Чтобы удобно обработать файл в servlet нам нужно подключить к проекту библиотеку apache-upload.
Порядок загрузки файла на сервер.
1. Вначале мы создаем фабрику по которой можем понять, какие данные есть в запросе. Данные могу быть: поля или файлы.
2. Получаем список всех данных в запросе. List<FileItem> items = upload.parseRequest(req);
3. Если элемент не поле, то это файл и из него можно прочитать весь входной поток и записать его в файл или напрямую в базу данных.