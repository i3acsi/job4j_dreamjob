1. Что такое сервлет?
Это интерфейс. Его реализации работают на сервере с клиентом по схеме запрос-ответ. Частный случай - HttpServlet, работает по протоколу http

2. Какова структура веб-проекта?
	Есть контейнер сервлетов, в который помещается веб проект:
* в корне будут лежать html, jsp файлы
* в папке WEB_INF:
    * web.xml - дескриптор развертывания, определяет маппинг url-servlet, некоторые другие параметры  приложения (например время жизни сессии)
    * в папке classes - скомпилированные классы: Сервлеты, Фильтры и т.д. т.е. код, написанный нами
    * в папке Lib - сторонние зависимости: те библиотеки, кторые были подключены в pom.xml

3. Что такое контейнер сервлетов?
	Программа, которая управляет жизненным циклом сервлетов. Работая на сервере, обеспечивает заимодействие по сети
клиента и сервлетов - формирует ответ на запрос клинта.
Кроме маршрутизации запросов, контейнер сервлетов выполняет и другие функции:
*Динамически генерирует HTML-страницы с JSP-файлов.
*Зашифровывает/расшифровывает HTTPS-сообщения.
*Предоставляет разграниченный доступ для администрирования сервлетов.

4. Каковы задачи, функциональность контейнера сервлетов?

5. Что вы знаете о сервлет фильтрах?
	Это ссвоего рода Request, Response препроцессор. т.е., преже чем попасть на соответсвующий сервлет, Req попадет
на соответствующие фильтры. А так же Resp перед отпарвкой клиенту так же попадаетв фильтр. Фильты могут их модифицировать или просто логировать события

6. Зачем нужны слушатели в сервлетах?
	Существует несколько интерфейсов, которые позволяют следить за событиями, связанными с сеансом, контекстом и запросом сервлета,
генерируемыми во время жизненного цикла Web-приложения.	Слушатели  - могут следить за тем, когда в соответсвующем компоненте произошли определенные
события - были инициализированы, или отслеживать время, когда они должны быть уничтожены, и когда атрибуты были добавлены или удалены.

* ServletRequestListener
* ServletRequestEvent
* ServletRequestAttributeListener
* ServletRequestAttributeEvent
Слушатели - это классы, с помощью которых можно отслеживать изменения ключевых параметров в веб-приложении.
Слушатели делятся на два уровня: уровень контекста (приложения, servlet-context-level) и уровень сессии (servlet-session-level)
Внутри уровней слушатели делятся на две группы: отслеживающие изменение атрибутов и отслеживающие изменения в жизненном цикле.
Для оповещений используются классы Event из пакета javax.servlet. В этих классах есть методы для получения самого объекта - ServletContextEvent: getServletContext()
ServletContextAttributeEvent - HttpSessionAttributeEvent: getHttpSession()

7. Когда вы будете использовать фильтры, а когда слушатели?
	Фильтры используются до того как запрос достигнет сервлета или после того, как ответ будет сгенерирован, но перед его отправкой пользователю.
 В то время как слушатели используются для обработки жизненных циклов внутренних объектов: сеансов и атрибутов в сервлете.
 Фильтры обрабатывают все проходящие мимо них запросы.
 Они не интересуются реализацией и взаимодействием сервлетов.
 Фильтры можно использовать:
 * для аутентификации пользователей (доступ к сервлетам)
 * шифрование/расшифровка передаваемых/получаемых данных.
 * логирование
	Слушатели более специфичны: реагируют только на указанные события, а не на все.
Они могут:
* слушатель контекста: создавать/завершать подключение к базе данных при старте/выключении приложения
*слушатель сессии: создавать/изменять объекты, специфичные для залогиненого пользователя. 

8. Как обработать исключения, выброшенные другим сервлетом в приложении?
	Основная идея заключается в том, чтобы отправить клиенту хотябы какой-то понятный ответ, если произошла ошибка в сервлете.
Даже если отправить просто статус ошибки - браузер сообщит об этом клиенту. Но так же можно сконфигурировать контейнер сервлетов так,
что при определенных ошибках, ответ ему отдавал бы определенный сервлет.

9. Что такое дескриптор развертывания?

10. Как реализовать запуск сервлета с запуском приложения?
Контейнер сервлетов обычно загружает сервлет при первом запросе клиента, но иногда необходимо загрузить сервлет прямо на старте приложения
(например если сервлет объемный и будет долго грузиться). Для этого необходимо использовать элемент load-on-startup в дескрипторе
(или аннотацию loadOnStartup), который укажет необходимость загрузки сервлета при запуске.
	<servlet>
    		<servlet-name>foo</servlet-name>
    		<servlet-class>com.foo.servlets.Foo</servlet-class>
    		<load-on-startup>5</load-on-startup>
	</servlet>
Значение должно быть int. Если значение отрицательное, то сервлет будет загружен при запросе клиента, а если 0 и далее, то загрузится
на старте приложения. Чем меньше число, тем раньше в очереди на загрузку будет сервлет.

11. Что представляет собой объект ServletConfig?
	Добавляет возможность сконфигурировать определенный сервлет через web.xml (или @WebInitParam). Для передачи конфигурационной
информации сервлету используется ServletConfig, за создание экземпляра которого ответственен контейнер сервлетов.
Для получения объекта ServletConfig данного сервлета используется метод getServletConfig().

12. Что представляет собой объект ServletContext?
	Предоставляет доступ к параметрам веб приложения сервлету. Объект ServletContext является уникальным и доступен всем
сервлетам веб приложения. Мы можем использовать объект ServletContext, когда нам необходимо предоставить доступ одному или нескольким
сервлетам к инициализированным параметрам веб приложения. Для этого используется элемент <context-param> в web.xml.
Объект ServletContext можно получить с помощью метода getServletContext() у интерфейса ServletConfig, Servlet.
Контейнеры сервлетов так же могут предоставлять context объекты, уникальные для группы сервлетов. Каждая из групп будет связана со своим
набором URL путей хоста. ServletContext был расширен в спецификации Servlet 3 и предоставляет программное добавление слушателей
и фильтров в приложение. Так же у этого интерфейса имеются множество полезных методов вроде getMimeType(), getResourceAsStream() и т.д..

13. В чем отличия ServletContext и ServletConfig?
* ServletConfig является уникальным объектом для каждого сервлета, в то время как ServletContext уникальный для всего приложения.
* ServletConfig используется для предоставления параметров инициализации сервлету, а ServletContext для предоставления параметров
инициализации приложения для всех сервлетов.
* У нас нет возможности устанавливать атрибуты в объекте ServletConfig, в то время как можно установить атрибуты в объекте ServletContext,
которые будут доступны другим сервлетам.

14. Что такое Request Dispatcher?
	Используется для передачи запроса другому ресурсу (это может быть HTML, JSP или другой сервлет в том же приложении).
Мы можем использовать это для добавления контента другого ресурса к ответу. Этот интерфейс используется для внутренней коммуникации
между сервлетами в одном контексте. В интерфейсе реализовано два метода:
* void forward(ServletRequest req, ServletResponse resp) – передает запрос из сервлета к другому ресурсу (сервлету, JSP или HTML файлу) на сервере.
* void include(ServletRequest req, ServletResponse resp) – включает контент ресурса (сервлет, JSP или HTML страница) в ответ.
Доступ к интерфейсу можно получить с помощью метода ServletContext getRequestDispatcher(String s). Путь должен начинаться с / ,
который будет интерпретироваться относительным текущего корневого пути контекста.

15. Как можно создать блокировку (deadlock) в сервлете?
Дедлок можно получить реализовав зацикленный вызов метода, например вызвав метод doPost() в методе doGet() и вызвать doGet() в методе doPost().

16. Как получить адрес сервлета на сервере?
Для получения актуального пути сервлета на сервере можно использовать эту конструкцию: getServletContext().getRealPath(request.getServletPath())

17. Как получить информацию о сервере из сервлета?
из сервлета: this.getServletContext().getServerInfo()

18. Как получить ip адрес клиента на сервере?
из сервлета: req.getRemoteAddr()

19. Что вы знаете о классах обертках (wrapper) для сервлетов?
В Servlet HTTP API предоставляются два класса обертки – HttpServletRequestWrapper и HttpServletResponseWrapper.
Они помогают разработчикам реализовывать собственные реализации типов request и response сервлета.

20. Каков жизненный цикл сервлета и когда какие методы вызываются?
Загрузка класса сервлета – когда контейнер получает запрос для сервлета, то происходит загрузка класса сервлета в память
и вызов конструктора без параметров.
Инициализация класса сервлета – после того как класс загружен контейнер инициализирует объект ServletConfig для этого сервлета и внедряет
его через init() метод. Это и есть место где сервлет класс преобразуется из обычного класса в сервлет.
Обработка запросов – после инициализации сервлет готов к обработке запросов. Для каждого запроса клиента сервлет контейнер порождает новую нить (поток) и
вызывает метод service() путем передачи ссылки на объект ответа и запроса.
Удаление из Service – когда контейнер останавливается или останавливается приложение, то контейнер сервлетов уничтожает классы сервлетов путем вызова destroy() метода.
	Можно описать как последовательность вызова методов: init(), service(), destroy().
public void init(ServletConfig config) – используется контейнером для инициализации сервлета. Вызывается один раз за время жизни сервлета.
public void service(ServletRequest request, ServletResponse response) – вызывается для каждого запроса. Метод не может быть вызван раньше выполнения init() метода.
public void destroy() – вызывается для уничтожения сервлета (один раз за время жизни сервлета).

21. Какие методы необходимо определить при создании сервлетов?
* задать url-mapping в web.xml или через аннотацию
* класс сервлета должен расширять HttpServlet
* в классе сервлета необходимо реализовать метод service или doGet / doPost

22. В каком случае вы будете переопределять метод service()?
 - если серлет будет одинаковым образом обрабатывать методы doGet, doPost

23. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?
    Инициализировать данные лучше переопределив метод init(), в котором получить доступ к параметрам инициализации сервлета через использование объекта ServletConfig.

24. В чем отличия GenericServlet и HttpServlet?
    Абстрактный класс GenericServlet – независимая от используемого протокола реализация интерфейса Servlet.
HttpServlet, как понятно из название, реализация интерфейса сервлета для протокола HTTP. Следует отметить, что HttpServlet extends GenericServlet.

25. Как вызвать из сервлета другой сервлет этого же и другого приложения?
    Если необходимо вызывать сервлет из того же приложения, мы можем вызвать другой сервлет с помощью RequestDispatcher forward() и include() методов
для доступа к дополнительным атрибутам в запросе для использования в другом сервлете. Метод forward() используется для передачи обработки запроса в другой сервлет.
Метод include() используется, если мы хотим вложить результат работы другого сервлета в возвращаемый ответ.
Если необходимо вызывать сервлет из другого приложения, то использовать RequestDispatcher уже не получится (определен для приложения).
Поэтому можно использовать ServletResponse sendRedirect() метод и предоставить полный URL из другого сервлета.
Для передачи данных можно использовать cookies как часть ответа сервлета, а потом использовать их в нашем сервлете.

26. Что вы знаете и в чем отличия методов forward() и sendRedirect()?
* RequestDispatcher forward() используется для проброски того же самого запроса к другому ресурсу, в то время как
ServletResponse sendRedirect() это двухшаговый метод. Во втором методе веб приложение возвращает ответ клиенту с status code 302 (redirect) с ссылкой для отправки запроса.
Клиент посылает полностью новый запрос.
forward() обрабатывается внутри контейнера, а sendRedirect() обрабатывается браузером.
Необходимо использовать forward() для организации доступа внутри одного и того же приложения, т.к. он быстрее sendRedirect(), которому требуется дополнительная сетевая работа.
В методе forward() браузер не знает о фактически обрабатываемом ресурсе и URL в строке остается прежним. В sendRedirect() методе URL адрес изменяется на пробрасываемый ресурс.
В методе forward() нельзя использовать для внедрения сервлета в другой контекст. Для этого можно использовать только sendRedirect().

27. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?
Методы класса HTTPServlet init() и destroy() вызываются один раз за жизненный цикл сервлета – поэтому по поводу них беспокоиться не стоит.
Методы service(), doGet(), doPost(), doFilter() вызываются на каждый запрос клиента и т.к. сервлеты используют многопоточность, то здесь нужно задумываться о потокобезопасной работе.
В случае наличия локальных переменных в этих методах нет необходимости думать о многопоточной безопасности, т.к. они будут созданы отдельно для каждой нити. Но если используются глобальные ресурсы, то необходимо использовать синхронизацию как и в любом многопоточном приложении Java.

28. В чем отличие между веб сервером и сервером приложений?
29. Какой метод HTTP не является неизменяемым?
30. Почему HttpServlet класс объявлен как абстрактный?


31. В чем разница между методами GET и POST?
32. Что такое MIME-тип?
33. Назовите преимущества Servlet над CGI?
34. Каковы наиболее распространенные задачи выполняются в Servlet контейнере?
35. В чем разница между PrintWriter и ServletOutputStream?
36. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?
37. Расскажите о интерфейсе SingleThreadModel.
38. Какие существуют атрибуты у сервлетов и какая сфера их применения?
39. Почему необходимо переопределить только init() метод без аргументов?
40. Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode() и decode()?
41. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?
42. Какие различные методы управления сессией в сервлетах вы знаете?
43. Что означает URL Rewriting?
44. Как применяются Cookies в сервлетах?
45. Как уведомить объект в сессии, что сессия недействительна или закончилась?
46. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?
47. Как мы можем обеспечить transport layer security для нашего веб приложения?
48. Как организовать подключение к базе дынных и обеспечить логирование log4j в сервлете?
49. Какие важные особенности существуют в Servlet 3?
50. Каковы различные способы аутентификации сервлета?
51. Написать сервлет, реализующий загрузку файла на сервер.